diff -rupN xbmc-master/configure.ac isengard/configure.ac
--- xbmc-master/configure.ac	2015-06-30 04:17:51.000000000 +1000
+++ isengard/configure.ac	2015-06-30 15:49:00.393720991 +1000
@@ -232,6 +232,11 @@ libusb_disabled_udev_found="== libusb di
 libcec_enabled="== libcec enabled. =="
 libcec_disabled="== libcec disabled. CEC adapter support will not be available. =="
 
+# Odroid stuff
+hybris_enabled="== Libhybris enabled. =="
+hybris_disabled="== Libhybris disabled. =="
+
+
 AC_ARG_WITH([ffmpeg],
   [AS_HELP_STRING([--with-ffmpeg],
   [ffmpeg options: auto (search pkg-config or auto build), force (always build ffmpeg), shared (link dynamically), path_to_ffmpeg [default=force]])],
@@ -553,7 +558,7 @@ AC_ARG_ENABLE([breakpad],
 
 AC_ARG_ENABLE([codec],
   [AS_HELP_STRING([--enable-codec],
-  [enable additional codecs from a list of comma separated names, (default is none, choices are amcodec, libstagefright and imxvpu)])],
+  [enable additional codecs from a list of comma separated names, (default is none, choices are mfc, amcodec, libstagefright and imxvpu)])],
   [add_codecs=$enableval],
   [add_codecs=no])
 
@@ -564,6 +569,14 @@ AC_ARG_ENABLE([libav-compat],
   [use_libav_hacks=$enableval],
   [use_libav_hacks=no])
 
+# Odroid stuff
+
+AC_ARG_ENABLE([hybris],
+  [AS_HELP_STRING([--enable-hybris],
+  [enable use of Libhybris (default is no) 'Linux only'])],
+  [use_hybris=$enableval],
+  [use_hybris=no])
+
 ### End of external library options
 
 if test "x$host_vendor" != "xapple"; then
@@ -1693,6 +1706,25 @@ else
   AC_MSG_NOTICE($libcap_disabled)
 fi
 
+# Odroid stuff
+
+if test "x$use_hybris" != "xno"; then
+  AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -DTARGET_HYBRIS")
+  USE_HYBRIS=1;
+  AC_DEFINE(HAS_EGLGLES, [1], [Define if supporting EGL based GLES Framebuffer])
+  AC_DEFINE(HAS_HYBRIS, [1], [Define if supporting Hybris based systems])
+  PKG_CHECK_MODULES([HWCOMPOSEREGL],  [hwcomposer-egl >= 0.1],
+    [INCLUDES="$INCLUDES -I/usr/include/hybris $HWCOMPOSEREGL_CFLAGS"; LIBS="$LIBS $HWCOMPOSEREGL_LIBS"],
+    AC_MSG_ERROR($missing_library))
+  PKG_CHECK_MODULES([HYBRISEGL],  [hybris-egl-platform >= 0.1],
+    [INCLUDES="$INCLUDES $HYBRISEGL_CFLAGS"; LIBS="$LIBS $HYBRISEGL_LIBS"],
+    AC_MSG_ERROR($missing_library))
+  PKG_CHECK_MODULES([LIBHARDWARE],  [libhardware >= 0.1],
+    [INCLUDES="$INCLUDES $LIBHARDWARE_CFLAGS"; LIBS="$LIBS $LIBHARDWARE_LIBS -lsync -lmedia"],
+    AC_MSG_ERROR($missing_library))
+fi
+
+
 # FFmpeg
 FFMPEG_LIBNAMES="libavcodec >= 56.26.100
                  libavfilter >= 5.11.102
@@ -1932,6 +1964,9 @@ esac
 # remember to convert commas to spaces
 for codecs in `echo $add_codecs | sed 's/,/ /g'`; do
   case $codecs in
+    *mfc*)
+        XB_ADD_CODEC([MFC], [mfc], [$codecs])
+        ;;
     *amcodec*)
         AC_CHECK_HEADER([amcodec/codec_error.h],, AC_MSG_ERROR($missing_headers))
         XB_ADD_CODEC([LIBAMCODEC], [amcodec], [$codecs])
@@ -2433,6 +2468,14 @@ else
   final_message="$final_message\n  additional codecs:\tNo"
 fi
 
+# Odroid stuff
+
+if test "x$use_hybris" != "xno"; then
+  final_message="$final_message\n  Odroid Hybris support:\tYes"
+else
+  final_message="$final_message\n  Odroid Hybris support:\tNo"
+fi
+
 ### External libraries messages
 
 if test "$host_vendor" = "apple" ; then
@@ -2642,6 +2685,7 @@ AC_SUBST(USE_SSE4)
 AC_SUBST(USE_MMAL)
 AC_SUBST(USE_X11)
 AC_SUBST(USE_BREAKPAD)
+AC_SUBST(USE_HYBRIS)
 
 # pushd and popd are not available in other shells besides bash, so implement
 # our own pushd/popd functions
diff -rupN xbmc-master/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp isengard/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
--- xbmc-master/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp	2015-06-30 04:17:51.000000000 +1000
+++ isengard/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp	2015-06-30 15:52:48.855880100 +1000
@@ -57,6 +57,9 @@
 #include "Overlay/DVDOverlayCodecTX3G.h"
 #include "Overlay/DVDOverlayCodecFFmpeg.h"
 
+#if defined(HAS_MFC)
+#include "Video/DVDVideoCodecMFC.h"
+#endif
 
 #include "DVDStreamInfo.h"
 #include "settings/AdvancedSettings.h"
@@ -199,6 +202,20 @@ CDVDVideoCodec* CDVDFactoryCodec::Create
 #else
   hwSupport += "MMAL:no ";
 #endif
+#if defined(HAS_MFC) && defined(_LINUX)
+  hwSupport += "MFC:yes ";
+#elif defined(_LINUX)
+  hwSupport += "MFC:no ";
+#endif
+
+#if defined(HAS_MFC)
+    if ( !hint.software )
+    {
+      if ( hint.codec == AV_CODEC_ID_H263 || hint.codec == AV_CODEC_ID_H264 || hint.codec == AV_CODEC_ID_MPEG4 || hint.codec == AV_CODEC_ID_MPEG2VIDEO || AV_CODEC_ID_MPEG1VIDEO || hint.codec == AV_CODEC_ID_VC1 )
+        if( (pCodec = OpenCodec(new CDVDVideoCodecMFC(), hint, options)) ) return pCodec;
+    }
+#endif
+
   CLog::Log(LOGDEBUG, "CDVDFactoryCodec: compiled in hardware support: %s", hwSupport.c_str());
 
   if (hint.stills && (hint.codec == AV_CODEC_ID_MPEG2VIDEO || hint.codec == AV_CODEC_ID_MPEG1VIDEO))
diff -rupN xbmc-master/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMFC.cpp isengard/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMFC.cpp
--- xbmc-master/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMFC.cpp	1970-01-01 10:00:00.000000000 +1000
+++ isengard/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMFC.cpp	2015-06-30 15:49:00.403720991 +1000
@@ -0,0 +1,755 @@
+/*
+ *      Copyright (C) 2005-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "system.h"
+#if (defined HAVE_CONFIG_H) && (!defined WIN32)
+  #include "config.h"
+#endif
+#include "DVDVideoCodecMFC.h"
+#include "DVDDemuxers/DVDDemux.h"
+#include "DVDStreamInfo.h"
+#include "DVDClock.h"
+#include "guilib/GraphicContext.h"
+#include "DVDCodecs/DVDCodecs.h"
+#include "DVDCodecs/DVDCodecUtils.h"
+
+#include "settings/Settings.h"
+#include "settings/DisplaySettings.h"
+#include "settings/AdvancedSettings.h"
+//#include "utils/fastmemcpy.h"
+
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <poll.h>
+#include <sys/mman.h>
+#include <dirent.h>
+#include "utils/log.h"
+
+#ifdef CLASSNAME
+#undef CLASSNAME
+#endif
+#define CLASSNAME "CDVDVideoCodecMFC"
+
+CDVDVideoCodecMFC::CDVDVideoCodecMFC() : CDVDVideoCodec() {
+  m_v4l2MFCOutputBuffers = NULL;
+  m_v4l2MFCCaptureBuffers = NULL;
+  m_v4l2FIMCCaptureBuffers = NULL;
+
+  m_MFCOutputBuffersCount = 0;
+  m_MFCCaptureBuffersCount = 0;
+  m_FIMCCaptureBuffersCount = 0;
+
+  m_iDecoderHandle = -1;
+  m_iConverterHandle = -1;
+  m_bVideoConvert = false;
+  m_bDropPictures = false;
+
+  m_iDequeuedToPresentBufferNumber = -1;
+
+  memzero(m_videoBuffer);
+}
+
+CDVDVideoCodecMFC::~CDVDVideoCodecMFC() {
+  Dispose();
+}
+
+bool CDVDVideoCodecMFC::OpenDevices() {
+  DIR *dir;
+  struct dirent *ent;
+
+  if ((dir = opendir ("/sys/class/video4linux/")) != NULL) {
+    while ((ent = readdir (dir)) != NULL) {
+      if (strncmp(ent->d_name, "video", 5) == 0) {
+        char *p;
+        char name[64];
+        char devname[64];
+        char sysname[64];
+        char drivername[32];
+        char target[1024];
+        int ret;
+
+        snprintf(sysname, 64, "/sys/class/video4linux/%s", ent->d_name);
+        snprintf(name, 64, "/sys/class/video4linux/%s/name", ent->d_name);
+
+        FILE* fp = fopen(name, "r");
+        if (fgets(drivername, 32, fp) != NULL) {
+          p = strchr(drivername, '\n');
+          if (p != NULL)
+            *p = '\0';
+        } else {
+          fclose(fp);
+          continue;
+        }
+        fclose(fp);
+
+        ret = readlink(sysname, target, sizeof(target));
+        if (ret < 0)
+          continue;
+        target[ret] = '\0';
+        p = strrchr(target, '/');
+        if (p == NULL)
+          continue;
+
+        sprintf(devname, "/dev/%s", ++p);
+
+        if (m_iDecoderHandle < 0 && strncmp(drivername, "s5p-mfc-dec", 11) == 0) {
+          struct v4l2_capability cap;
+          int fd = open(devname, O_RDWR | O_NONBLOCK, 0);
+          if (fd > 0) {
+            memzero(cap);
+            ret = ioctl(fd, VIDIOC_QUERYCAP, &cap);
+            if (ret == 0)
+              if (cap.capabilities & V4L2_CAP_STREAMING &&
+                (cap.capabilities & V4L2_CAP_VIDEO_M2M_MPLANE ||
+                (cap.capabilities & (V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_VIDEO_OUTPUT_MPLANE)))) {
+                m_iDecoderHandle = fd;
+                CLog::Log(LOGDEBUG, "%s::%s - Found %s %s", CLASSNAME, __func__, drivername, devname);
+                struct v4l2_format fmt;
+                memzero(fmt);
+                fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+                fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_NV12M;
+                if (ioctl(m_iDecoderHandle, VIDIOC_TRY_FMT, &fmt) == 0) {
+                  CLog::Log(LOGDEBUG, "%s::%s - Direct decoding to untiled picture is supported, no conversion needed", CLASSNAME, __func__);
+                  m_iConverterHandle = -1;
+                  return true;
+                }
+              }
+          }
+          if (m_iDecoderHandle < 0)
+            close(fd);
+        }
+        if (m_iConverterHandle < 0 && strstr(drivername, "fimc") != NULL && strstr(drivername, "m2m") != NULL) {
+          struct v4l2_capability cap;
+          int fd = open(devname, O_RDWR | O_NONBLOCK, 0);
+          if (fd > 0) {
+            memzero(cap);
+            ret = ioctl(fd, VIDIOC_QUERYCAP, &cap);
+            if (ret == 0)
+              if (cap.capabilities & V4L2_CAP_STREAMING &&
+                (cap.capabilities & V4L2_CAP_VIDEO_M2M_MPLANE ||
+                (cap.capabilities & (V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_VIDEO_OUTPUT_MPLANE)))) {
+                m_iConverterHandle = fd;
+                CLog::Log(LOGDEBUG, "%s::%s - Found %s %s", CLASSNAME, __func__, drivername, devname);
+              }
+          }
+          if (m_iConverterHandle < 0)
+            close(fd);
+        }
+        if (m_iDecoderHandle >= 0 && m_iConverterHandle >= 0)
+          return true;
+      }
+    }
+    closedir (dir);
+  }
+  return false;
+}
+
+void CDVDVideoCodecMFC::Dispose() {
+
+  if (m_iConverterHandle >= 0) {
+    m_v4l2FIMCCaptureBuffers = CLinuxV4l2::FreeBuffers(m_FIMCCaptureBuffersCount, m_v4l2FIMCCaptureBuffers);
+    if (CLinuxV4l2::StreamOn(m_iConverterHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, VIDIOC_STREAMOFF))
+      CLog::Log(LOGDEBUG, "%s::%s - FIMC OUTPUT Stream OFF", CLASSNAME, __func__);
+    if (CLinuxV4l2::StreamOn(m_iConverterHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, VIDIOC_STREAMOFF))
+      CLog::Log(LOGDEBUG, "%s::%s - FIMC CAPTURE Stream OFF", CLASSNAME, __func__);
+
+    m_FIMCCaptureBuffersCount = 0;
+    CLog::Log(LOGDEBUG, "%s::%s - FIMC Closing", CLASSNAME, __func__);
+    close(m_iConverterHandle);
+    m_iConverterHandle = -1;
+  }
+  if (m_iDecoderHandle >= 0) {
+    m_v4l2MFCOutputBuffers = CLinuxV4l2::FreeBuffers(m_MFCOutputBuffersCount, m_v4l2MFCOutputBuffers);
+    m_v4l2MFCCaptureBuffers = CLinuxV4l2::FreeBuffers(m_MFCCaptureBuffersCount, m_v4l2MFCCaptureBuffers);
+    if (CLinuxV4l2::StreamOn(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, VIDIOC_STREAMOFF))
+      CLog::Log(LOGDEBUG, "%s::%s - MFC OUTPUT Stream OFF", CLASSNAME, __func__);
+    if (CLinuxV4l2::StreamOn(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, VIDIOC_STREAMOFF))
+      CLog::Log(LOGDEBUG, "%s::%s - MFC CAPTURE Stream OFF", CLASSNAME, __func__);
+
+    m_MFCOutputBuffersCount = 0;
+    m_MFCCaptureBuffersCount = 0;
+    CLog::Log(LOGDEBUG, "%s::%s - MFC Closing", CLASSNAME, __func__);
+    close(m_iDecoderHandle);
+    m_iDecoderHandle = -1;
+  }
+
+  m_iDequeuedToPresentBufferNumber = -1;
+
+  memzero(m_videoBuffer);
+
+}
+time_t tt;
+int cnt;
+
+bool CDVDVideoCodecMFC::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options) {
+  struct v4l2_format fmt;
+  struct v4l2_control ctrl;
+  struct v4l2_crop crop;
+  int iResultVideoWidth;
+  int iResultLineSize;
+  int iResultVideoHeight;
+  int ret = 0;
+  unsigned int extraSize = 0;
+  uint8_t *extraData = NULL;
+
+  m_hints = hints;
+  if(m_hints.width<900)
+	return false; 
+  if (m_hints.software)
+    return false;
+//  return false;
+  dtime = 2000 + XbmcThreads::SystemClockMillis();
+  sec = m_reset = 0;
+  Dispose();
+  if (!OpenDevices()) {
+    CLog::Log(LOGERROR, "%s::%s - Needed devices not found", CLASSNAME, __func__);
+    return false;
+  }
+
+  m_bVideoConvert = m_converter.Open(m_hints.codec, (uint8_t *)m_hints.extradata, m_hints.extrasize, true);
+
+  if(m_bVideoConvert) {
+    if(m_converter.GetExtraData() != NULL && m_converter.GetExtraSize() > 0) {
+      extraSize = m_converter.GetExtraSize();
+      extraData = m_converter.GetExtraData();
+    }
+  } else {
+    if(m_hints.extrasize > 0 && m_hints.extradata != NULL) {
+      extraSize = m_hints.extrasize;
+      extraData = (uint8_t*)m_hints.extradata;
+    }
+  }
+
+  // Setup MFC OUTPUT queue (OUTPUT - name of the queue where TO encoded frames are streamed, CAPTURE - name of the queue where FROM decoded frames are taken)
+  // Set MFC OUTPUT format
+  memzero(fmt);
+  switch(m_hints.codec)
+  {
+/*
+    case CODEC_TYPE_VC1_RCV:
+      return V4L2_PIX_FMT_VC1_ANNEX_L;
+*/
+    case AV_CODEC_ID_VC1:
+      fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_VC1_ANNEX_G;
+      m_name = "mfc-vc1";
+      break;
+    case AV_CODEC_ID_MPEG1VIDEO:
+      fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_MPEG1;
+      m_name = "mfc-mpeg1";
+      break;
+    case AV_CODEC_ID_MPEG2VIDEO:
+      fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_MPEG2;
+      m_name = "mfc-mpeg2";
+      break;
+    case AV_CODEC_ID_MPEG4:
+      fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_MPEG4;
+      m_name = "mfc-mpeg4";
+      break;
+    case AV_CODEC_ID_H263:
+      fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_H263;
+      m_name = "mfc-h263";
+      break;
+    case AV_CODEC_ID_H264:
+      fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_H264;
+      m_name = "mfc-h264";
+      break;
+    default:
+      return false;
+      break;
+  }
+  fmt.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+  fmt.fmt.pix_mp.plane_fmt[0].sizeimage = STREAM_BUFFER_SIZE;
+  ret = ioctl(m_iDecoderHandle, VIDIOC_S_FMT, &fmt);
+  if (ret != 0) {
+    CLog::Log(LOGERROR, "%s::%s - MFC OUTPUT S_FMT Failed, errno %d", CLASSNAME, __func__, errno);
+    return false;
+  }
+  // Request MFC OUTPUT buffers
+  m_MFCOutputBuffersCount = CLinuxV4l2::RequestBuffer(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, V4L2_MEMORY_MMAP, MFC_OUTPUT_BUFFERS_CNT);
+  if (m_MFCOutputBuffersCount == V4L2_ERROR) {
+    CLog::Log(LOGERROR, "%s::%s - MFC OUTPUT REQBUFS Failed, errno %d", CLASSNAME, __func__, errno);
+    return false;
+  }
+  CLog::Log(LOGDEBUG, "%s::%s - MFC OUTPUT REQBUFS Number of MFC buffers is %d (requested %d)", CLASSNAME, __func__, m_MFCOutputBuffersCount, MFC_OUTPUT_BUFFERS_CNT);
+
+  // Memory Map MFC OUTPUT buffers
+  m_v4l2MFCOutputBuffers = (V4L2Buffer *)calloc(m_MFCOutputBuffersCount, sizeof(V4L2Buffer));
+  if(!m_v4l2MFCOutputBuffers) {
+    CLog::Log(LOGERROR, "%s::%s - MFC OUTPUT Cannot allocate buffers in memory", CLASSNAME, __func__);
+    return false;
+  }
+  if(!CLinuxV4l2::MmapBuffers(m_iDecoderHandle, m_MFCOutputBuffersCount, m_v4l2MFCOutputBuffers, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, V4L2_MEMORY_MMAP, false)) {
+    CLog::Log(LOGERROR, "%s::%s - MFC OUTPUT Cannot mmap buffers, errno %d", CLASSNAME, __func__, errno);
+    return false;
+  }
+  CLog::Log(LOGDEBUG, "%s::%s - MFC OUTPUT Succesfully mmapped %d buffers", CLASSNAME, __func__, m_MFCOutputBuffersCount);
+
+  // Prepare header
+  m_v4l2MFCOutputBuffers[0].iBytesUsed[0] = extraSize;
+  memcpy((uint8_t *)m_v4l2MFCOutputBuffers[0].cPlane[0], extraData, extraSize);
+
+  // Queue header to MFC OUTPUT queue
+  ret = CLinuxV4l2::QueueBuffer(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, V4L2_MEMORY_MMAP, &m_v4l2MFCOutputBuffers[0]);
+  if (ret == V4L2_ERROR) {
+    CLog::Log(LOGERROR, "%s::%s - MFC OUTPUT Error queuing header, errno %d", CLASSNAME, __func__, errno);
+    return false;
+  }
+  CLog::Log(LOGDEBUG, "%s::%s - MFC OUTPUT <- %d header of size %d", CLASSNAME, __func__, ret, extraSize);
+
+  // Setup MFC CAPTURE format
+  if (m_iConverterHandle < 0) {
+    memzero(fmt);
+    fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+    fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_NV12M;
+    ret = ioctl(m_iDecoderHandle, VIDIOC_S_FMT, &fmt);
+    if (ret != 0) {
+      CLog::Log(LOGERROR, "%s::%s - MFC CAPTURE S_FMT Failed, errno %d", CLASSNAME, __func__, errno);
+      return false;
+    }
+    CLog::Log(LOGDEBUG, "%s::%s - MFC CAPTURE S_FMT: fmt 0x%x", CLASSNAME, __func__, fmt.fmt.pix_mp.pixelformat);
+  }
+
+  // STREAMON on MFC OUTPUT
+  if (!CLinuxV4l2::StreamOn(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, VIDIOC_STREAMON)) {
+    CLog::Log(LOGERROR, "%s::%s - MFC OUTPUT Failed to Stream ON, errno %d", CLASSNAME, __func__, errno);
+    return false;
+  }
+  CLog::Log(LOGDEBUG, "%s::%s - MFC OUTPUT Stream ON", CLASSNAME, __func__);
+
+  // Get MFC CAPTURE picture format to check, and to setup FIMC converter if needed
+  memzero(fmt);
+  fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+  ret = ioctl(m_iDecoderHandle, VIDIOC_G_FMT, &fmt);
+  if (ret) {
+    CLog::Log(LOGERROR, "%s::%s - MFC CAPTURE G_FMT Failed, errno %d", CLASSNAME, __func__, errno);
+    return false;
+  }
+  CLog::Log(LOGDEBUG, "%s::%s - MFC CAPTURE G_FMT: fmt 0x%x, (%dx%d), plane[0]=%d plane[1]=%d", CLASSNAME, __func__, fmt.fmt.pix_mp.pixelformat, fmt.fmt.pix_mp.width, fmt.fmt.pix_mp.height, fmt.fmt.pix_mp.plane_fmt[0].sizeimage, fmt.fmt.pix_mp.plane_fmt[1].sizeimage);
+  // Size of resulting picture coming out of MFC
+  // It will be aligned by 16 since the picture is tiled
+  // We need this to know where to split buffer line by line
+  iResultLineSize = fmt.fmt.pix_mp.width;
+
+  // Get MFC CAPTURE crop to check and setup Line Size as well as FIMC converter if needed
+  memzero(crop);
+  crop.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+  ret = ioctl(m_iDecoderHandle, VIDIOC_G_CROP, &crop);
+  if (ret) {
+    CLog::Log(LOGERROR, "%s::%s - MFC CAPTURE G_CROP Failed to get crop information, errno %d", CLASSNAME, __func__, errno);
+    return false;
+  }
+  CLog::Log(LOGDEBUG, "%s::%s - MFC CAPTURE G_CROP (%dx%d)", CLASSNAME, __func__, crop.c.width, crop.c.height);
+  // This is the picture boundaries we are interested in, everything outside is alignement because of tiled MFC output
+  iResultVideoWidth = crop.c.width;
+  iResultVideoHeight = crop.c.height;
+
+  // Get MFC needed number of buffers on CAPTURE
+  memzero(ctrl);
+  ctrl.id = V4L2_CID_MIN_BUFFERS_FOR_CAPTURE;
+  ret = ioctl(m_iDecoderHandle, VIDIOC_G_CTRL, &ctrl);
+  if (ret) {
+    CLog::Log(LOGERROR, "%s::%s - MFC CAPTURE Failed to get the number of buffers required, errno %d", CLASSNAME, __func__, errno);
+    return false;
+  }
+  CLog::Log(LOGDEBUG, "%s::%s - MFC CAPTURE want %d buffers", CLASSNAME, __func__, ctrl.value);
+  //We need 50% more extra capture buffers for cozy decoding,
+  //but not less than 3
+  if (m_MFCCaptureBuffersCount < 6)
+    m_MFCCaptureBuffersCount = (int)(ctrl.value + 3);
+  else
+    m_MFCCaptureBuffersCount = (int)(ctrl.value * 1.5);
+
+  // Request MFC CAPTURE buffers
+  CLog::Log(LOGDEBUG, "%s::%s - MFC CAPTURE Going to ask for %d buffers", CLASSNAME, __func__, m_MFCCaptureBuffersCount);
+  m_MFCCaptureBuffersCount = CLinuxV4l2::RequestBuffer(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, V4L2_MEMORY_MMAP, m_MFCCaptureBuffersCount);
+  if (m_MFCCaptureBuffersCount == V4L2_ERROR) {
+    CLog::Log(LOGERROR, "%s::%s - MFC CAPTURE REQBUFS Failed, errno %d", CLASSNAME, __func__, errno);
+    return false;
+  }
+  CLog::Log(LOGDEBUG, "%s::%s - MFC CAPTURE REQBUFS Number of buffers allowed by MFC %d", CLASSNAME, __func__, m_MFCCaptureBuffersCount);
+
+  // Allocate, Memory Map and queue MFC CAPTURE buffers
+  m_v4l2MFCCaptureBuffers = (V4L2Buffer *)calloc(m_MFCCaptureBuffersCount, sizeof(V4L2Buffer));
+  if(!m_v4l2MFCCaptureBuffers) {
+    CLog::Log(LOGERROR, "%s::%s - MFC CAPTURE Cannot allocate memory for buffers", CLASSNAME, __func__);
+    return false;
+  }
+  if(!CLinuxV4l2::MmapBuffers(m_iDecoderHandle, m_MFCCaptureBuffersCount, m_v4l2MFCCaptureBuffers, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, V4L2_MEMORY_MMAP, true)) {
+    CLog::Log(LOGERROR, "%s::%s - MFC CAPTURE Cannot mmap memory for buffers, errno %d", CLASSNAME, __func__, errno);
+    return false;
+  }
+  CLog::Log(LOGDEBUG, "%s::%s - MFC CAPTURE Succesfully allocated, mmapped and queued %d buffers", CLASSNAME, __func__, m_MFCCaptureBuffersCount);
+
+  // STREAMON on mfc CAPTURE
+  if (!CLinuxV4l2::StreamOn(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, VIDIOC_STREAMON)) {
+	CLog::Log(LOGERROR, "%s::%s - MFC CAPTURE Failed to Stream ON, errno %d", CLASSNAME, __func__, errno);
+    return false;
+  }
+  CLog::Log(LOGDEBUG, "%s::%s - MFC CAPTURE Stream ON", CLASSNAME, __func__);
+
+  if (m_iConverterHandle > -1) {
+
+  // Setup FIMC OUTPUT fmt with data from MFC CAPTURE
+    fmt.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+    ret = ioctl(m_iConverterHandle, VIDIOC_S_FMT, &fmt);
+    if (ret != 0) {
+      CLog::Log(LOGERROR, "%s::%s - FIMC OUTPUT S_FMT Failed, errno %d", CLASSNAME, __func__, errno);
+      return false;
+    }
+    CLog::Log(LOGDEBUG, "%s::%s - FIMC OUTPUT S_FMT: fmt 0x%x, (%dx%d), plane[0]=%d plane[1]=%d", CLASSNAME, __func__, fmt.fmt.pix_mp.pixelformat, fmt.fmt.pix_mp.width, fmt.fmt.pix_mp.height, fmt.fmt.pix_mp.plane_fmt[0].sizeimage, fmt.fmt.pix_mp.plane_fmt[1].sizeimage);
+
+    // Setup FIMC OUTPUT crop with data from MFC CAPTURE
+    crop.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+    if (ioctl(m_iConverterHandle, VIDIOC_S_CROP, &crop)) {
+      CLog::Log(LOGERROR, "%s::%s - FIMC OUTPUT S_CROP Failed to set crop information, errno %d", CLASSNAME, __func__, errno);
+      return false;
+    }
+    CLog::Log(LOGDEBUG, "%s::%s - FIMC OUTPUT S_CROP (%dx%d)", CLASSNAME, __func__, crop.c.width, crop.c.height);
+//  FIMC scaling doesn't work good on width not a division of 16. It reports the picture to be scaled as requested,
+//  but real scale size cannot be surely determined (it is a floor of alignement to 16).
+//  I decided that than working around all this bugs it would be better to disable scaling at all. XBMC will scale picture itself good enough
+/*
+    // Calculate FIMC final picture size be scaled to fit screen
+    RESOLUTION_INFO res_info =  CDisplaySettings::Get().GetResolutionInfo(g_graphicsContext.GetVideoResolution());
+    double ratio = std::min((double)res_info.iScreenWidth / (double)iResultVideoWidth, (double)res_info.iScreenHeight / (double)iResultVideoHeight);
+    iResultVideoWidth = (int)((double)iResultVideoWidth * ratio);
+    iResultVideoHeight = (int)((double)iResultVideoHeight * ratio);
+    // Since (int) is a floor down, if resulting picture is not even, the natural way to align will be to add 1 pixel
+    if (iResultVideoWidth%2)
+      iResultVideoWidth++;
+    if (iResultVideoHeight%2)
+      iResultVideoHeight++;
+
+    CLog::Log(LOGDEBUG, "%s::%s - Scaling source Video to resulting size (%dx%d)", CLASSNAME, __func__, iResultVideoWidth, iResultVideoHeight);
+*/
+
+    // Request FIMC OUTPUT buffers
+    ret = CLinuxV4l2::RequestBuffer(m_iConverterHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, V4L2_MEMORY_USERPTR, m_MFCCaptureBuffersCount);
+    if (ret == V4L2_ERROR) {
+      CLog::Log(LOGERROR, "%s::%s - FIMC OUTPUT REQBUFS Failed, errno %d", CLASSNAME, __func__, errno);
+      return false;
+    }
+    CLog::Log(LOGDEBUG, "%s::%s - FIMC OUTPUT REQBUFS Number of buffers is %d", CLASSNAME, __func__, ret);
+
+    // Setup FIMC CAPTURE
+    memzero(fmt);
+    fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_NV12M;
+    fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+    fmt.fmt.pix_mp.width = iResultVideoWidth;
+    fmt.fmt.pix_mp.height = iResultVideoHeight;
+    fmt.fmt.pix_mp.field = V4L2_FIELD_ANY;
+    ret = ioctl(m_iConverterHandle, VIDIOC_S_FMT, &fmt);
+    if (ret != 0) {
+      CLog::Log(LOGERROR, "%s::%s - FIMC CAPTURE S_FMT Failed, errno %d", CLASSNAME, __func__, errno);
+      return false;
+    }
+    CLog::Log(LOGDEBUG, "%s::%s - FIMC CAPTURE S_FMT: fmt 0x%x, (%dx%d)", CLASSNAME, __func__, fmt.fmt.pix_mp.pixelformat, fmt.fmt.pix_mp.width, fmt.fmt.pix_mp.height);
+
+    // Get FIMC produced picture details to adjust output buffer parameters with these values
+    memzero(fmt);
+    fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+    ret = ioctl(m_iConverterHandle, VIDIOC_G_FMT, &fmt);
+    if (ret) {
+      CLog::Log(LOGERROR, "%s::%s - FIMC CAPTURE G_FMT Failed, errno %d", CLASSNAME, __func__, errno);
+      return false;
+    }
+    CLog::Log(LOGDEBUG, "%s::%s - FIMC CAPTURE G_FMT: fmt 0x%x, (%dx%d), plane[0]=%d plane[1]=%d", CLASSNAME, __func__, fmt.fmt.pix_mp.pixelformat, fmt.fmt.pix_mp.width, fmt.fmt.pix_mp.height, fmt.fmt.pix_mp.plane_fmt[0].sizeimage, fmt.fmt.pix_mp.plane_fmt[1].sizeimage);
+    // The length of the line on the result buffer
+    iResultLineSize = fmt.fmt.pix_mp.width;
+
+    memzero(crop);
+    crop.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+    if (ioctl(m_iConverterHandle, VIDIOC_G_CROP, &crop)) {
+      CLog::Log(LOGERROR, "%s::%s - FIMC CAPTURE G_CROP Failed, errno %d", CLASSNAME, __func__, errno);
+      return false;
+    }
+    CLog::Log(LOGDEBUG, "%s::%s - FIMC CAPTURE G_CROP (%dx%d)", CLASSNAME, __func__, crop.c.width, crop.c.height);
+    // Width and Height returned after this call is the real resulting picture size produced by FIMC
+    iResultVideoWidth = crop.c.width;
+    iResultVideoHeight = crop.c.height;
+
+    // Request FIMC CAPTURE buffers
+    m_FIMCCaptureBuffersCount = CLinuxV4l2::RequestBuffer(m_iConverterHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, V4L2_MEMORY_MMAP, FIMC_CAPTURE_BUFFERS_CNT);
+    if (m_FIMCCaptureBuffersCount == V4L2_ERROR) {
+      CLog::Log(LOGERROR, "%s::%s - FIMC CAPTURE REQBUFS Failed, errno %d", CLASSNAME, __func__, errno);
+      return false;
+    }
+    CLog::Log(LOGDEBUG, "%s::%s - FIMC CAPTURE REQBUFS Number of buffers is %d", CLASSNAME, __func__, m_FIMCCaptureBuffersCount);
+
+    // Allocate, Memory Map and queue FIMC CAPTURE buffers
+    m_v4l2FIMCCaptureBuffers = (V4L2Buffer *)calloc(m_FIMCCaptureBuffersCount, sizeof(V4L2Buffer));
+    if(!m_v4l2FIMCCaptureBuffers) {
+     CLog::Log(LOGERROR, "%s::%s - FIMC CAPTURE Cannot allocate memory for buffers", CLASSNAME, __func__);
+     return false;
+    }
+    if(!CLinuxV4l2::MmapBuffers(m_iConverterHandle, m_FIMCCaptureBuffersCount, m_v4l2FIMCCaptureBuffers, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, V4L2_MEMORY_MMAP, true)) {
+      CLog::Log(LOGERROR, "%s::%s - FIMC CAPTURE Cannot mmap for capture buffers, errno %d", CLASSNAME, __func__, errno);
+      return false;
+    }
+    CLog::Log(LOGDEBUG, "%s::%s - FIMC CAPTURE Succesfully allocated, mmapped and queued %d buffers", CLASSNAME, __func__, m_FIMCCaptureBuffersCount);
+
+    if (!CLinuxV4l2::StreamOn(m_iConverterHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, VIDIOC_STREAMON)) {
+      CLog::Log(LOGERROR, "%s::%s - FIMC OUTPUT Failed to Stream ON, errno %d", CLASSNAME, __func__, errno);
+      return false;
+    }
+    CLog::Log(LOGDEBUG, "%s::%s - FIMC OUTPUT Stream ON", CLASSNAME, __func__);
+    if (!CLinuxV4l2::StreamOn(m_iConverterHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, VIDIOC_STREAMON)) {
+      CLog::Log(LOGERROR, "%s::%s - FIMC CAPTURE Failed to Stream ON, errno %d", CLASSNAME, __func__, errno);
+      return false;
+    }
+    CLog::Log(LOGDEBUG, "%s::%s - FIMC CAPTURE Stream ON", CLASSNAME, __func__);
+
+  }
+
+  m_videoBuffer.iFlags          = DVP_FLAG_ALLOCATED;
+
+  m_videoBuffer.color_range     = 0;
+  m_videoBuffer.color_matrix    = 4;
+
+  m_videoBuffer.iDisplayWidth   = iResultVideoWidth;
+  m_videoBuffer.iDisplayHeight  = iResultVideoHeight;
+  m_videoBuffer.iWidth          = iResultVideoWidth;
+  m_videoBuffer.iHeight         = iResultVideoHeight;
+
+  m_videoBuffer.data[0]         = NULL;
+  m_videoBuffer.data[1]         = NULL;
+  m_videoBuffer.data[2]         = NULL;
+  m_videoBuffer.data[3]         = NULL;
+
+  m_videoBuffer.format          = RENDER_FMT_NV12;
+  m_videoBuffer.iLineSize[0]    = iResultLineSize;
+  m_videoBuffer.iLineSize[1]    = iResultLineSize;
+  m_videoBuffer.iLineSize[2]    = 0;
+  m_videoBuffer.iLineSize[3]    = 0;
+  m_videoBuffer.pts             = DVD_NOPTS_VALUE;
+  m_videoBuffer.dts             = DVD_NOPTS_VALUE;
+
+  CLog::Log(LOGNOTICE, "%s::%s - MFC Setup succesfull, start streaming", CLASSNAME, __func__);
+
+  return true;
+}
+
+void CDVDVideoCodecMFC::SetDropState(bool bDrop) {
+
+  m_bDropPictures = bDrop;
+  if (m_bDropPictures)
+    m_videoBuffer.iFlags |=  DVP_FLAG_DROPPED;
+  else
+    m_videoBuffer.iFlags &= ~DVP_FLAG_DROPPED;
+
+}
+
+int CDVDVideoCodecMFC::Decode(BYTE* pData, int iSize, double dts, double pts) {
+  int ret = -1;
+  int index = 0;
+  double dequeuedTimestamp;
+  if (m_reset) {
+	m_reset = 0;
+	Reset();
+	dtime = XbmcThreads::SystemClockMillis();
+  }
+  if (m_hints.ptsinvalid)
+    pts = DVD_NOPTS_VALUE;
+
+  //unsigned int dtime = XbmcThreads::SystemClockMillis();
+  CLog::Log(LOGDEBUG, "%s::%s - input frame iSize %d, pts %lf, dts %lf", CLASSNAME, __func__, iSize, pts, dts);
+
+  if(pData) {
+    int demuxer_bytes = iSize;
+    uint8_t *demuxer_content = pData;
+
+	// Find buffer ready to be filled
+    while (index < m_MFCOutputBuffersCount && m_v4l2MFCOutputBuffers[index].bQueue)
+      index++;
+
+    if (index >= m_MFCOutputBuffersCount) { //all input buffers are busy, dequeue needed
+      ret = CLinuxV4l2::PollOutput(m_iDecoderHandle, 1000/3); // Wait up to 1/3 (3 fps) sec for buffer to become available to recieve new encoded frame.
+                                                              // POLLIN - Capture, POLLOUT - Output
+      if (ret == V4L2_ERROR) {
+        CLog::Log(LOGERROR, "%s::%s - MFC OUTPUT PollOutput Error", CLASSNAME, __func__);
+        return VC_ERROR;
+      } else if (ret == V4L2_READY) {
+        index = CLinuxV4l2::DequeueBuffer(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, V4L2_MEMORY_MMAP, &dequeuedTimestamp);
+        if (index < 0) {
+          CLog::Log(LOGERROR, "%s::%s - MFC OUTPUT error dequeue output buffer, got number %d, errno %d", CLASSNAME, __func__, index, errno);
+          return VC_FLUSHED;
+        }
+        CLog::Log(LOGDEBUG, "%s::%s - MFC OUTPUT -> %d", CLASSNAME, __func__, index);
+        m_v4l2MFCOutputBuffers[index].bQueue = false;
+      } else if (ret == V4L2_BUSY) { // buffer is still busy
+        CLog::Log(LOGERROR, "%s::%s - MFC OUTPUT All buffers are queued and busy, no space for new frame to decode. Very broken situation.", CLASSNAME, __func__);
+        return VC_PICTURE; // MFC is so busy it cannot accept more input frames, call ::Decode with pData = NULL to request a picture dequeue
+                           // FIXME
+                           // This will actually cause the current encoded frame to be lost in void, so this has to be fully reworked to queues storing all frames coming in
+                           // In current realization the picture will distort in this case scenarios
+      } else {
+        CLog::Log(LOGERROR, "%s::%s - MFC OUTPUT PollOutput error %d, errno %d", CLASSNAME, __func__, ret, errno);
+        return VC_ERROR;
+      }
+    }
+
+    if(m_bVideoConvert) {
+      m_converter.Convert(demuxer_content, demuxer_bytes);
+      demuxer_bytes = m_converter.GetConvertSize();
+      demuxer_content = m_converter.GetConvertBuffer();
+    }
+
+    m_v4l2MFCOutputBuffers[index].iBytesUsed[0] = (demuxer_bytes < m_v4l2MFCOutputBuffers[index].iSize[0]) ? demuxer_bytes : m_v4l2MFCOutputBuffers[index].iSize[0];
+    memcpy((uint8_t *)m_v4l2MFCOutputBuffers[index].cPlane[0], demuxer_content, m_v4l2MFCOutputBuffers[index].iBytesUsed[0]);
+    m_v4l2MFCOutputBuffers[index].timestamp = pts;
+    ret = CLinuxV4l2::QueueBuffer(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, V4L2_MEMORY_MMAP, &m_v4l2MFCOutputBuffers[index]);
+    if (ret == V4L2_ERROR) {
+      CLog::Log(LOGERROR, "%s::%s - MFC OUTPUT Failed to queue buffer with index %d, errno %d", CLASSNAME, __func__, index, errno);
+      return VC_FLUSHED;
+    }
+    CLog::Log(LOGDEBUG, "%s::%s - MFC OUTPUT <- %d", CLASSNAME, __func__, index);
+  }
+
+  if (m_iDequeuedToPresentBufferNumber >= 0) {
+    if (m_iConverterHandle > -1) {
+     if (!m_v4l2FIMCCaptureBuffers[m_iDequeuedToPresentBufferNumber].bQueue) {
+        ret = CLinuxV4l2::QueueBuffer(m_iConverterHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, V4L2_MEMORY_MMAP, &m_v4l2FIMCCaptureBuffers[m_iDequeuedToPresentBufferNumber]);
+        if (ret == V4L2_ERROR) {
+          CLog::Log(LOGERROR, "%s::%s - FIMC CAPTURE Failed to queue buffer with index %d, errno %d", CLASSNAME, __func__, m_iDequeuedToPresentBufferNumber, errno);
+          return VC_FLUSHED;
+        }
+        CLog::Log(LOGDEBUG, "%s::%s - FIMC CAPTURE <- %d", CLASSNAME, __func__, m_iDequeuedToPresentBufferNumber);
+        m_iDequeuedToPresentBufferNumber = -1;
+      }
+    } else {
+     if (!m_v4l2MFCCaptureBuffers[m_iDequeuedToPresentBufferNumber].bQueue) {
+        ret = CLinuxV4l2::QueueBuffer(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, V4L2_MEMORY_MMAP, &m_v4l2MFCCaptureBuffers[m_iDequeuedToPresentBufferNumber]);
+        if (ret == V4L2_ERROR) {
+          CLog::Log(LOGERROR, "%s::%s - MFC CAPTURE Failed to queue buffer with index %d, errno %d", CLASSNAME, __func__, m_iDequeuedToPresentBufferNumber, errno);
+          return VC_FLUSHED;
+        }
+        CLog::Log(LOGDEBUG, "%s::%s - MFC CAPTURE <- %d", CLASSNAME, __func__, m_iDequeuedToPresentBufferNumber);
+        m_iDequeuedToPresentBufferNumber = -1;
+      }
+    }
+  }
+
+  // Dequeue decoded frame
+  index = CLinuxV4l2::DequeueBuffer(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, V4L2_MEMORY_MMAP, &dequeuedTimestamp);
+  if (index < 0) {
+    if (errno == EAGAIN) // Buffer is still busy, queue more
+      return VC_BUFFER;
+    CLog::Log(LOGERROR, "%s::%s - MFC CAPTURE error dequeue output buffer, got number %d, errno %d", CLASSNAME, __func__, index, errno);
+    return VC_FLUSHED;
+  }
+  m_v4l2MFCCaptureBuffers[index].bQueue = false;
+  m_v4l2MFCCaptureBuffers[index].timestamp = dequeuedTimestamp;
+  CLog::Log(LOGDEBUG, "%s::%s - MFC CAPTURE -> %d", CLASSNAME, __func__, index);
+
+  if (m_bDropPictures) {
+    CLog::Log(LOGWARNING, "%s::%s - Dropping frame with index %d", CLASSNAME, __func__, index);
+    // Queue it back to MFC CAPTURE since the picture is dropped anyway
+    ret = CLinuxV4l2::QueueBuffer(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, V4L2_MEMORY_MMAP, &m_v4l2MFCCaptureBuffers[index]);
+    if (ret < 0) {
+      CLog::Log(LOGERROR, "%s::%s - MFC CAPTURE Failed to queue buffer with index %d, errno %d", CLASSNAME, __func__, index, errno);
+      return VC_FLUSHED;
+    }
+    CLog::Log(LOGDEBUG, "%s::%s - MFC CAPTURE <- %d", CLASSNAME, __func__, index);
+    return VC_BUFFER; // Continue, we have no picture to show
+  } else {
+    if (m_iConverterHandle > -1) {
+      ret = CLinuxV4l2::QueueBuffer(m_iConverterHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, V4L2_MEMORY_USERPTR, &m_v4l2MFCCaptureBuffers[index]);
+      if (ret == V4L2_ERROR) {
+        CLog::Log(LOGERROR, "%s::%s - FIMC OUTPUT Failed to queue buffer with index %d, errno %d", CLASSNAME, __func__, index, errno);
+        return VC_FLUSHED;
+      }
+      CLog::Log(LOGDEBUG, "%s::%s - FIMC OUTPUT <- %d", CLASSNAME, __func__, index);
+
+      index = CLinuxV4l2::DequeueBuffer(m_iConverterHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, V4L2_MEMORY_MMAP, &dequeuedTimestamp);
+      if (index < 0) {
+        if (errno == EAGAIN) // Dequeue buffer not ready, need more data on input. EAGAIN = 11
+          return VC_BUFFER;
+        CLog::Log(LOGERROR, "%s::%s - FIMC CAPTURE error dequeue output buffer, got number %d, errno %d", CLASSNAME, __func__, index, errno);
+        return VC_FLUSHED;
+      }
+      CLog::Log(LOGDEBUG, "%s::%s - FIMC CAPTURE -> %d", CLASSNAME, __func__, index);
+
+      ret = CLinuxV4l2::DequeueBuffer(m_iConverterHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, V4L2_MEMORY_USERPTR, &dequeuedTimestamp);
+      if (ret < 0) {
+        if (errno == EAGAIN) // Dequeue buffer not ready, need more data on input. EAGAIN = 11
+          return VC_BUFFER;
+        CLog::Log(LOGERROR, "%s::%s - FIMC OUTPUT error dequeue output buffer, got number %d, errno %d", CLASSNAME, __func__, ret, errno);
+        return VC_FLUSHED;
+      }
+      CLog::Log(LOGDEBUG, "%s::%s - FIMC OUTPUT -> %d", CLASSNAME, __func__, ret);
+      // Queue it back to MFC CAPTURE
+      if (CLinuxV4l2::QueueBuffer(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, V4L2_MEMORY_MMAP, &m_v4l2MFCCaptureBuffers[ret]) < 0) {
+        CLog::Log(LOGERROR, "%s::%s - MFC CAPTURE Failed to queue buffer with index %d, errno %d", CLASSNAME, __func__, ret, errno);
+        return VC_FLUSHED;
+      }
+      CLog::Log(LOGDEBUG, "%s::%s - MFC CAPTURE <- %d", CLASSNAME, __func__, ret);
+
+      m_v4l2FIMCCaptureBuffers[index].bQueue = false;
+      m_v4l2FIMCCaptureBuffers[index].timestamp = dequeuedTimestamp;
+      m_videoBuffer.data[0]         = (BYTE*)m_v4l2FIMCCaptureBuffers[index].cPlane[0];
+      m_videoBuffer.data[1]         = (BYTE*)m_v4l2FIMCCaptureBuffers[index].cPlane[1];
+      m_videoBuffer.pts             = m_v4l2FIMCCaptureBuffers[index].timestamp;
+    } else {
+      m_videoBuffer.data[0]         = (BYTE*)m_v4l2MFCCaptureBuffers[index].cPlane[0];
+      m_videoBuffer.data[1]         = (BYTE*)m_v4l2MFCCaptureBuffers[index].cPlane[1];
+      m_videoBuffer.pts             = m_v4l2MFCCaptureBuffers[index].timestamp;
+    }
+    m_iDequeuedToPresentBufferNumber = index;
+  }
+
+  //msg("Decode time: %d", XbmcThreads::SystemClockMillis() - dtime);
+  return VC_PICTURE | VC_BUFFER; // Picture is finally ready to be processed further and more info can be enqueued
+}
+
+void CDVDVideoCodecMFC::Reset() {
+
+  CLog::Log(LOGERROR, "%s::%s - Codec Reset. Reinitializing", CLASSNAME, __func__);
+  CDVDCodecOptions options;
+  // We need full MFC/FIMC reset with device reopening.
+  // I wasn't able to reinitialize both IP's without fully closing and reopening them.
+  // There are always some clips that cause MFC or FIMC go into state which cannot be reset without close/open
+  Open(m_hints, options);
+
+}
+
+bool CDVDVideoCodecMFC::GetPicture(DVDVideoPicture* pDvdVideoPicture) {
+  unsigned int ctime = XbmcThreads::SystemClockMillis();
+  if ((int ) (ctime - dtime) > 2500 ) dtime = ctime;  //do not reset when pausing
+  else if (( int) (ctime - dtime) > 2000) {
+	 CLog::Log(LOGDEBUG, "%s::%s - GetPicture dtime = %d, ctime = %d, sec= %d, reset = %d ", CLASSNAME, __func__,dtime, ctime, sec, m_reset);
+	dtime = ctime;
+//	if( sec < 30 ) m_reset = 1;; // if the average for the last 2 seconds is less than 30 frames, Reset
+	sec = 0;
+  }
+  sec++;
+  CLog::Log(LOGDEBUG, "%s::%s - GetPicture", CLASSNAME, __func__);
+  *pDvdVideoPicture = m_videoBuffer;
+  CLog::Log(LOGDEBUG, "%s::%s - output frame pts %lf", CLASSNAME, __func__, m_videoBuffer.pts);
+  
+  return true;
+
+}
+
+bool CDVDVideoCodecMFC::ClearPicture(DVDVideoPicture* pDvdVideoPicture) {
+  return CDVDVideoCodec::ClearPicture(pDvdVideoPicture);
+}
diff -rupN xbmc-master/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMFC.h isengard/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMFC.h
--- xbmc-master/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMFC.h	1970-01-01 10:00:00.000000000 +1000
+++ isengard/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMFC.h	2015-06-30 15:49:00.408720991 +1000
@@ -0,0 +1,83 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "DVDVideoCodec.h"
+#include "DVDStreamInfo.h"
+#include "utils/BitstreamConverter.h"
+#include "xbmc/linux/LinuxV4l2.h"
+
+#ifndef V4L2_CAP_VIDEO_M2M_MPLANE
+  #define V4L2_CAP_VIDEO_M2M_MPLANE 0x00004000
+#endif
+
+#define STREAM_BUFFER_SIZE            1048576 //compressed frame size buffer. for unknown reason, possibly the firmware bug,
+                                              //if set to lower values it corrupts adjacent value in the setup data structure for h264 streams
+                                              //and leads to stream hangs on heavy frames
+#define FIMC_CAPTURE_BUFFERS_CNT      3 //2 begins to be slow.
+#define MFC_OUTPUT_BUFFERS_CNT        3 //1 doesn't work at all, 2 is enough most of the times, but in a rare case of interlaced video two buffers
+                                        //must be queued all the time to get fill picture from interlaced frames, so let's have them 3
+
+#define memzero(x) memset(&(x), 0, sizeof (x))
+
+class CDVDVideoCodecMFC : public CDVDVideoCodec
+{
+public:
+  CDVDVideoCodecMFC();
+  virtual ~CDVDVideoCodecMFC();
+  virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options);
+  virtual void Dispose();
+  virtual int Decode(BYTE* pData, int iSize, double dts, double pts);
+  virtual void Reset();
+  bool GetPictureCommon(DVDVideoPicture* pDvdVideoPicture);
+  virtual bool GetPicture(DVDVideoPicture* pDvdVideoPicture);
+  virtual bool ClearPicture(DVDVideoPicture* pDvdVideoPicture);
+  virtual void SetDropState(bool bDrop);
+  virtual const char* GetName() { return m_name.c_str(); }; // m_name is never changed after open
+
+protected:
+  std::string m_name;
+  unsigned int sec;
+  unsigned int dtime,m_reset;
+
+  int m_iDecoderHandle;
+  int m_iConverterHandle;
+
+  int m_MFCOutputBuffersCount;
+  int m_MFCCaptureBuffersCount;
+  int m_FIMCCaptureBuffersCount;
+
+  V4L2Buffer *m_v4l2MFCOutputBuffers;
+  V4L2Buffer *m_v4l2MFCCaptureBuffers;
+  V4L2Buffer *m_v4l2FIMCCaptureBuffers;
+
+  int m_iDequeuedToPresentBufferNumber;
+
+  bool m_bVideoConvert;
+  CDVDStreamInfo m_hints;
+
+  CBitstreamConverter m_converter;
+  bool m_bDropPictures;
+
+  DVDVideoPicture   m_videoBuffer;
+
+  bool OpenDevices();
+};
diff -rupN xbmc-master/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in isengard/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in
--- xbmc-master/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in	2015-06-30 04:17:51.000000000 +1000
+++ isengard/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in	2015-06-30 15:49:00.408720991 +1000
@@ -41,6 +41,11 @@ ifeq (@USE_MMAL@,1)
 SRCS += MMALCodec.cpp
 endif
 
+ifeq (@USE_MFC@,1)
+SRCS += DVDVideoCodecMFC.cpp
+endif
+
+
 LIB=Video.a
 
 include @abs_top_srcdir@/Makefile.include
diff -rupN xbmc-master/xbmc/linux/LinuxV4l2.cpp isengard/xbmc/linux/LinuxV4l2.cpp
--- xbmc-master/xbmc/linux/LinuxV4l2.cpp	1970-01-01 10:00:00.000000000 +1000
+++ isengard/xbmc/linux/LinuxV4l2.cpp	2015-06-30 15:49:00.408720991 +1000
@@ -0,0 +1,314 @@
+/*
+ *      Copyright (C) 2005-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "system.h"
+#if (defined HAVE_CONFIG_H) && (!defined WIN32)
+  #include "config.h"
+#endif
+#include "LinuxV4l2.h"
+
+#include "xbmc/utils/log.h"
+
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <poll.h>
+#include <sys/mman.h>
+#include <linux/media.h>
+
+#ifdef CLASSNAME
+#undef CLASSNAME
+#endif
+#define CLASSNAME "CLinuxV4l2"
+
+CLinuxV4l2::CLinuxV4l2()
+{
+}
+
+CLinuxV4l2::~CLinuxV4l2()
+{
+}
+
+int CLinuxV4l2::RequestBuffer(int device, enum v4l2_buf_type type, enum v4l2_memory memory, int numBuffers)
+{
+  struct v4l2_requestbuffers reqbuf;
+  int ret = 0;
+
+  if(device < 0)
+    return false;
+
+  memset(&reqbuf, 0, sizeof(struct v4l2_requestbuffers));
+
+  reqbuf.type     = type;
+  reqbuf.memory   = memory;
+  reqbuf.count    = numBuffers;
+
+  ret = ioctl(device, VIDIOC_REQBUFS, &reqbuf);
+  if (ret)
+  {
+    CLog::Log(LOGERROR, "%s::%s - Request buffers", CLASSNAME, __func__);
+    return V4L2_ERROR;
+  }
+
+  return reqbuf.count;
+}
+
+bool CLinuxV4l2::StreamOn(int device, enum v4l2_buf_type type, int onoff)
+{
+  int ret = 0;
+  enum v4l2_buf_type setType = type;
+
+  if(device < 0)
+    return false;
+
+  ret = ioctl(device, onoff, &setType);
+  if(ret)
+    return false;
+
+  return true;
+}
+
+bool CLinuxV4l2::MmapBuffers(int device, int count, V4L2Buffer *v4l2Buffers, enum v4l2_buf_type type, enum v4l2_memory memory, bool queue)
+{
+  struct v4l2_buffer buf;
+  struct v4l2_plane planes[V4L2_NUM_MAX_PLANES];
+  int ret;
+  int i, j;
+
+  if(device < 0 || !v4l2Buffers || count == 0)
+    return false;
+
+  for(i = 0; i < count; i++)
+  {
+    memset(&buf, 0, sizeof(struct v4l2_buffer));
+    memset(&planes, 0, sizeof(struct v4l2_plane) * V4L2_NUM_MAX_PLANES);
+    buf.type      = type;
+    buf.memory    = memory;
+    buf.index     = i;
+    buf.m.planes  = planes;
+    buf.length    = V4L2_NUM_MAX_PLANES;
+
+    ret = ioctl(device, VIDIOC_QUERYBUF, &buf);
+    if (ret)
+    {
+      CLog::Log(LOGERROR, "%s::%s - Query buffer", CLASSNAME, __func__);
+      return false;
+    }
+
+    V4L2Buffer *buffer = &v4l2Buffers[i];
+
+    buffer->iNumPlanes = 0;
+    buffer->bQueue = false;
+    for (j = 0; j < buf.length; j++)
+    {
+      buffer->iSize[j]       = buf.m.planes[j].length;
+      buffer->iBytesUsed[j]  = buf.m.planes[j].bytesused;
+      if(buffer->iSize[j])
+      {
+        buffer->cPlane[j] = mmap(NULL, buf.m.planes[j].length, PROT_READ | PROT_WRITE,
+                       MAP_SHARED, device, buf.m.planes[j].m.mem_offset);
+        if(buffer->cPlane[j] == MAP_FAILED)
+        {
+          CLog::Log(LOGERROR, "%s::%s - Mmapping buffer", CLASSNAME, __func__);
+          return false;
+        }
+        buffer->iOffset[j] = buf.m.planes[j].m.mem_offset;
+        memset(buffer->cPlane[j], 0, buf.m.planes[j].length);
+        buffer->iNumPlanes++;
+      }
+    }
+    buffer->iIndex = i;
+
+    if(queue)
+      QueueBuffer(device, type, memory, buffer);
+  }
+
+  return true;
+}
+
+V4L2Buffer *CLinuxV4l2::FreeBuffers(int count, V4L2Buffer *v4l2Buffers)
+{
+  int i, j;
+
+  if(v4l2Buffers != NULL)
+  {
+    for(i = 0; i < count; i++)
+    {
+      V4L2Buffer *buffer = &v4l2Buffers[i];
+
+      for (j = 0; j < buffer->iNumPlanes; j++)
+      {
+        if(buffer->cPlane[j] && buffer->cPlane[j] != MAP_FAILED)
+          munmap(buffer->cPlane[j], buffer->iSize[j]);
+      }
+    }
+    free(v4l2Buffers);
+  }
+  return NULL;
+}
+
+int CLinuxV4l2::DequeueBuffer(int device, enum v4l2_buf_type type, enum v4l2_memory memory, double *dequeuedTimestamp)
+{
+  struct v4l2_buffer vbuf;
+  struct v4l2_plane  vplanes[V4L2_NUM_MAX_PLANES];
+  int ret = 0;
+
+  if(device < 0)
+    return V4L2_ERROR;
+
+  memset(&vplanes, 0, sizeof(struct v4l2_plane) * V4L2_NUM_MAX_PLANES);
+  memset(&vbuf, 0, sizeof(struct v4l2_buffer));
+  vbuf.type     = type;
+  vbuf.memory   = memory;
+  vbuf.m.planes = vplanes;
+  vbuf.length   = V4L2_NUM_MAX_PLANES;
+
+  ret = ioctl(device, VIDIOC_DQBUF, &vbuf);
+  if (ret) {
+    if (errno != EAGAIN)
+      CLog::Log(LOGERROR, "%s::%s - Dequeue buffer", CLASSNAME, __func__);
+    return V4L2_ERROR;
+  }
+
+  if (type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {
+    // Unbox two 32-bit integers from struct timeval received from MFC back into one 64-bit double expected by XBMC as pts
+    // WARNING: It will work only if double is 64-bit.
+    // Since MFC is IP available only in Samsung Exynos ARM's and the code is for V4L2 for linux it should work.
+    uint32_t pts[2] = { vbuf.timestamp.tv_sec, vbuf.timestamp.tv_usec };
+    *dequeuedTimestamp = *((double*)&pts[0]);;
+  }
+  return vbuf.index;
+}
+
+int CLinuxV4l2::QueueBuffer(int device, enum v4l2_buf_type type, enum v4l2_memory memory, V4L2Buffer *buffer)
+{
+  struct v4l2_buffer vbuf;
+  struct v4l2_plane  vplanes[buffer->iNumPlanes];
+  int ret = 0;
+
+  if(!buffer || device <0)
+    return V4L2_ERROR;
+
+  memset(&vplanes, 0, sizeof(struct v4l2_plane) * buffer->iNumPlanes);
+  memset(&vbuf, 0, sizeof(struct v4l2_buffer));
+  vbuf.type     = type;
+  vbuf.memory   = memory;
+  vbuf.index    = buffer->iIndex;
+  vbuf.m.planes = vplanes;
+  vbuf.length   = buffer->iNumPlanes;
+  if (type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {
+    vbuf.flags |= V4L2_BUF_FLAG_TIMESTAMP_COPY;
+    // This will box 64-bit double given as pts from XBMC into two 32-bit integers available in struct timeval which MFC expects.
+    // WARNING: This values has nothing to do with real timestamp of the frame, it is just two 32-bit halves of 64-bit double
+    // and must be unboxed back the same way on deqeue. It will work only if double is 64-bit.
+    // Since MFC is IP available only in Samsung Exynos ARM's, and the code is for V4L2 for linux it should work.
+    // The values will be just copied by driver from input frame to output frame and will not affect decoding in any way
+    uint32_t* pts = (uint32_t*)&buffer->timestamp;
+    vbuf.timestamp.tv_sec = pts[0];
+    vbuf.timestamp.tv_usec = pts[1];
+  }
+
+  for (int i = 0; i < buffer->iNumPlanes; i++)
+  {
+    switch (vbuf.memory) {
+      case V4L2_MEMORY_USERPTR:
+        vplanes[i].m.userptr = (unsigned long)buffer->cPlane[i];
+        break;
+      case V4L2_MEMORY_MMAP:
+        vplanes[i].m.mem_offset = buffer->iOffset[i];
+        break;
+    }
+    vplanes[i].length      = buffer->iSize[i];
+    vplanes[i].bytesused   = buffer->iBytesUsed[i];
+  }
+
+  ret = ioctl(device, VIDIOC_QBUF, &vbuf);
+  if (ret)
+  {
+    CLog::Log(LOGERROR, "%s::%s - Queue buffer", CLASSNAME, __func__);
+    return V4L2_ERROR;
+  }
+  buffer->bQueue = true;
+
+  return vbuf.index;
+}
+
+int CLinuxV4l2::PollInput(int device, int timeout)
+{
+  int ret = 0;
+  struct pollfd p;
+  p.fd = device;
+  p.events = POLLIN | POLLERR;
+
+  ret = poll(&p, 1, timeout);
+  if (ret < 0)
+  {
+    CLog::Log(LOGERROR, "%s::%s - Polling input", CLASSNAME, __func__);
+    return V4L2_ERROR;
+  }
+  else if (ret == 0)
+  {
+    return V4L2_BUSY;
+  }
+
+  return V4L2_READY;
+}
+
+int CLinuxV4l2::PollOutput(int device, int timeout)
+{
+  int ret = 0;
+  struct pollfd p;
+  p.fd = device;
+  p.events = POLLOUT | POLLERR;
+
+  ret = poll(&p, 1, timeout);
+  if (ret < 0)
+  {
+    CLog::Log(LOGERROR, "%s::%s - Polling output", CLASSNAME, __func__);
+    return V4L2_ERROR;
+  }
+  else if (ret == 0)
+  {
+    return V4L2_BUSY;
+  }
+
+  return V4L2_READY;
+}
+
+int CLinuxV4l2::SetControllValue(int device, int id, int value)
+{
+  struct v4l2_control control;
+  int ret;
+
+  control.id    = id;
+  control.value = value;
+
+  ret = ioctl(device, VIDIOC_S_CTRL, &control);
+
+  if(ret < 0)
+  {
+    CLog::Log(LOGERROR, "%s::%s - Set controll if %d value %d\n", CLASSNAME, __func__, id, value);
+    return V4L2_ERROR;
+  }
+
+  return V4L2_OK;
+}
diff -rupN xbmc-master/xbmc/linux/LinuxV4l2.h isengard/xbmc/linux/LinuxV4l2.h
--- xbmc-master/xbmc/linux/LinuxV4l2.h	1970-01-01 10:00:00.000000000 +1000
+++ isengard/xbmc/linux/LinuxV4l2.h	2015-06-30 15:49:00.408720991 +1000
@@ -0,0 +1,77 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <linux/videodev2.h>
+
+#ifndef V4L2_BUF_FLAG_TIMESTAMP_COPY
+  #define V4L2_BUF_FLAG_TIMESTAMP_COPY 0x4000
+#endif
+
+#define V4L2_ERROR -1
+#define V4L2_BUSY  1
+#define V4L2_READY 2
+#define V4L2_OK    3
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define V4L2_NUM_MAX_PLANES 3
+
+typedef struct V4L2Buffer
+{
+  int   iSize[V4L2_NUM_MAX_PLANES];
+  int   iOffset[V4L2_NUM_MAX_PLANES];
+  int   iBytesUsed[V4L2_NUM_MAX_PLANES];
+  void  *cPlane[V4L2_NUM_MAX_PLANES];
+  int   iNumPlanes;
+  int   iIndex;
+  bool  bQueue;
+  double timestamp;
+} V4L2Buffer;
+
+#ifdef __cplusplus
+}
+#endif
+
+class CLinuxV4l2
+{
+public:
+  CLinuxV4l2();
+  virtual ~CLinuxV4l2();
+
+  static int RequestBuffer(int device, enum v4l2_buf_type type, enum v4l2_memory memory, int numBuffers);
+  static bool StreamOn(int device, enum v4l2_buf_type type, int onoff);
+  static bool MmapBuffers(int device, int count, V4L2Buffer *v4l2Buffers, enum v4l2_buf_type type, enum v4l2_memory memory, bool queue = true);
+  static V4L2Buffer *FreeBuffers(int count, V4L2Buffer *v4l2Buffers);
+
+  static int DequeueBuffer(int device, enum v4l2_buf_type type, enum v4l2_memory memory, double *dequeuedTimestamp);
+  static int QueueBuffer(int device, enum v4l2_buf_type type, enum v4l2_memory memory, V4L2Buffer *buffer);
+
+  static int PollInput(int device, int timeout);
+  static int PollOutput(int device, int timeout);
+  static int SetControllValue(int device, int id, int value);
+};
+
+inline int v4l2_align(int v, int a) {
+  return ((v + a - 1) / a) * a;
+}
diff -rupN xbmc-master/xbmc/linux/Makefile.in isengard/xbmc/linux/Makefile.in
--- xbmc-master/xbmc/linux/Makefile.in	2015-06-30 04:17:51.000000000 +1000
+++ isengard/xbmc/linux/Makefile.in	2015-06-30 15:49:00.408720991 +1000
@@ -12,6 +12,7 @@ SRCS += XFileUtils.cpp
 SRCS += XHandle.cpp
 SRCS += XMemUtils.cpp
 SRCS += XTimeUtils.cpp
+SRCS += LinuxV4l2.cpp
 
 SRCS += RBP.cpp
 
diff -rupN xbmc-master/xbmc/windowing/egl/EGLNativeTypeHybris.cpp isengard/xbmc/windowing/egl/EGLNativeTypeHybris.cpp
--- xbmc-master/xbmc/windowing/egl/EGLNativeTypeHybris.cpp	1970-01-01 10:00:00.000000000 +1000
+++ isengard/xbmc/windowing/egl/EGLNativeTypeHybris.cpp	2015-06-30 15:49:00.413720991 +1000
@@ -0,0 +1,341 @@
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#if defined(TARGET_HYBRIS)
+#include <hwcomposerwindow/hwcomposer_window.h>
+#include <hardware/hardware.h>
+#include <hardware/hwcomposer.h>
+#endif
+
+#include "system.h"
+#include <EGL/egl.h>
+#include "EGLNativeTypeHybris.h"
+#include "utils/log.h"
+#include "guilib/gui3d.h"
+
+#include "utils/StringUtils.h"
+
+CEvent displayEvent;
+CEvent paintEvent;
+
+CHybrisVideoRenderer::CHybrisVideoRenderer(hwc_display_contents_1_t **bufferList,
+    hwc_composer_device_1_t *hwcDevicePtr,
+    HWComposerNativeWindow *nativeWindow)
+    : CThread("HybrisVideoRenderer")
+{
+    m_bufferList = bufferList;
+    m_hwcDevicePtr = hwcDevicePtr;
+    m_hwNativeWindow = nativeWindow;
+}
+
+CHybrisVideoRenderer::~CHybrisVideoRenderer()
+{
+}
+
+buffer_handle_t handle = 0, old_handle = 0;
+void CHybrisVideoRenderer::Process()
+{
+//  m_clock = 0;
+//  m_lastTime = XbmcThreads::SystemClockMillis();
+  printf("We started!\n");
+  while (!m_bStop)
+  {
+  HWComposerNativeWindow* window = (HWComposerNativeWindow*)m_hwNativeWindow;
+  HWComposerNativeWindowBuffer *front = NULL;
+//  if(displayEvent.getNumWaits()) {
+//    printf("Swap waiting!");
+//    displayEvent.Set();
+//  }
+  window->lockFrontBuffer(&front);
+  if(!front){
+    if(!handle) {
+      printf("No buffer!\n");
+      continue;
+    }
+  }
+  else {
+    /*if(!handle)*/ handle = front->handle;
+  }
+//  printf("Front handle %u\n", handle);
+  m_bufferList[0]->hwLayers[0].handle = handle;
+  m_bufferList[0]->hwLayers[0].compositionType = HWC_FRAMEBUFFER_TARGET;
+  m_bufferList[0]->hwLayers[1].handle = NULL;
+  m_bufferList[0]->hwLayers[1].flags = HWC_SKIP_LAYER;
+  m_bufferList[0]->hwLayers[1].compositionType = HWC_FRAMEBUFFER_TARGET;
+
+  int oldretire = m_bufferList[0]->retireFenceFd;
+  int oldrelease = m_bufferList[0]->hwLayers[1].releaseFenceFd;
+  int oldrelease2 = m_bufferList[0]->hwLayers[0].releaseFenceFd;
+
+  int err = m_hwcDevicePtr->prepare(m_hwcDevicePtr, 1, m_bufferList);
+  if(err) {
+    CLog::Log(LOGERROR, "prepare() failed!");
+  }
+
+  err = m_hwcDevicePtr->set(m_hwcDevicePtr, 1, m_bufferList);
+  if(front)
+    window->unlockFrontBuffer(front);
+
+
+    paintEvent.Set();
+  if (oldrelease != -1)
+  {
+    printf("old release wait1\n");
+    sync_wait(oldrelease, -1);
+    close(oldrelease);
+  }
+  if (oldrelease2 != -1)
+  {
+ //   printf("old release wait2\n");
+    sync_wait(oldrelease2, -1);
+    close(oldrelease2);
+  }
+
+  if (oldretire != -1)
+  {
+    printf("old release wait3\n");
+    sync_wait(oldretire, -1);
+    close(oldretire);
+  }
+
+  }
+}
+
+CEGLNativeTypeHybris::CEGLNativeTypeHybris()
+#if defined(TARGET_HYBRIS)
+ : m_hwcModule(NULL), m_bufferList(NULL), m_hwcDevicePtr(NULL)
+{
+  m_nativeWindow = NULL;
+  m_hwNativeWindow = NULL;
+  m_swNativeWindow = NULL;
+}
+#else
+{
+}
+#endif
+
+CEGLNativeTypeHybris::~CEGLNativeTypeHybris()
+{
+} 
+
+bool CEGLNativeTypeHybris::CheckCompatibility()
+{
+#if defined(TARGET_HYBRIS)
+  if(hw_get_module(HWC_HARDWARE_MODULE_ID, (const hw_module_t **) &m_hwcModule))
+  {
+    return false;
+  }
+
+  if(hwc_open_1(m_hwcModule, &m_hwcDevicePtr))
+  {
+    return false;
+  }
+
+  m_hwcDevicePtr->blank(m_hwcDevicePtr, 0, 0);
+  m_hwcDevicePtr->eventControl(m_hwcDevicePtr, 0, HWC_EVENT_VSYNC, 0);
+  return true;
+#else
+  return false;
+#endif
+}
+
+void CEGLNativeTypeHybris::Initialize()
+{
+}
+
+void CEGLNativeTypeHybris::Destroy()
+{
+  return;
+}
+
+bool CEGLNativeTypeHybris::CreateNativeDisplay()
+{
+  m_nativeDisplay = EGL_DEFAULT_DISPLAY;
+  return true;
+}
+
+bool CEGLNativeTypeHybris::CreateNativeWindow()
+{
+#if defined(TARGET_HYBRIS)
+  RESOLUTION_INFO res;
+  if (!GetNativeResolution(&res))
+    return false;
+
+  m_hwNativeWindow = new HWComposerNativeWindow(res.iWidth, res.iHeight, HAL_PIXEL_FORMAT_RGBA_8888);
+  if (m_hwNativeWindow == NULL)
+  {
+    CLog::Log(LOGERROR, "HWComposer native window failed!");
+    return false;
+  }
+  m_swNativeWindow = (static_cast<ANativeWindow *> (m_hwNativeWindow));
+
+  size_t size = sizeof(hwc_display_contents_1_t) + 2 * sizeof(hwc_layer_1_t);
+  
+  hwc_display_contents_1_t *list = (hwc_display_contents_1_t *) malloc(size);
+  m_bufferList = (hwc_display_contents_1_t **) malloc(HWC_NUM_DISPLAY_TYPES * sizeof(hwc_display_contents_1_t *));
+  const hwc_rect_t r = { 0, 0, res.iWidth, res.iHeight };
+  int counter = 0;
+//  for (; counter < HWC_NUM_DISPLAY_TYPES; counter++)
+  m_bufferList[0] = list;
+  m_bufferList[1] = NULL;
+
+  hwc_layer_1_t *layer = &list->hwLayers[0];
+  memset(layer, 0, sizeof(hwc_layer_1_t));
+  layer->compositionType = HWC_FRAMEBUFFER_TARGET;
+  layer->hints = 0;
+  layer->flags = 0;
+  layer->handle = 0;
+  layer->transform = 0;
+  layer->blending = HWC_BLENDING_NONE;
+  layer->sourceCrop = r;
+  layer->displayFrame = r;
+  layer->visibleRegionScreen.numRects = 1;
+  layer->visibleRegionScreen.rects = &layer->displayFrame;
+  layer->acquireFenceFd = -1;
+  layer->releaseFenceFd = -1;
+  layer = &list->hwLayers[1];
+  memset(layer, 0, sizeof(hwc_layer_1_t));
+  layer->compositionType = HWC_FRAMEBUFFER_TARGET;
+  layer->hints = 0;
+  layer->flags = 0;
+  layer->handle = 0;
+  layer->transform = 0;
+  layer->blending = HWC_BLENDING_NONE;
+  layer->sourceCrop = r;
+  layer->displayFrame = r;
+  layer->visibleRegionScreen.numRects = 1;
+  layer->visibleRegionScreen.rects = &layer->displayFrame;
+  layer->acquireFenceFd = -1;
+  layer->releaseFenceFd = -1;
+
+  list->retireFenceFd = -1;
+  list->flags = HWC_GEOMETRY_CHANGED;
+  list->numHwLayers = 1;
+  m_videoRenderThread = new CHybrisVideoRenderer(m_bufferList, m_hwcDevicePtr,
+    m_hwNativeWindow);
+  m_videoRenderThread->Create(true, THREAD_MINSTACKSIZE);
+  return true;
+#else
+  return false;
+#endif
+}
+
+bool CEGLNativeTypeHybris::GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const
+{
+  if (!nativeDisplay)
+    return false;
+
+  *nativeDisplay = (XBNativeDisplayType*) &m_nativeDisplay;
+
+  return true;
+}
+
+bool CEGLNativeTypeHybris::GetNativeWindow(XBNativeWindowType **nativeWindow) const
+{
+  if (!nativeWindow)
+    return false;
+
+#if defined(TARGET_HYBRIS)
+  *nativeWindow = (XBNativeWindowType*) &m_swNativeWindow;
+  return (m_swNativeWindow != NULL);
+#else
+  return false;
+#endif
+}
+
+bool CEGLNativeTypeHybris::DestroyNativeDisplay()
+{
+  return true;
+}
+
+bool CEGLNativeTypeHybris::DestroyNativeWindow()
+{
+  m_nativeWindow = NULL;
+  return true;
+}
+
+bool CEGLNativeTypeHybris::GetNativeResolution(RESOLUTION_INFO *res) const
+{
+#if defined(TARGET_HYBRIS)
+  uint32_t configs[5];
+  size_t numConfigs = 5;
+
+  int err = m_hwcDevicePtr->getDisplayConfigs(m_hwcDevicePtr, 0, configs, &numConfigs);
+  if (err) {
+      CLog::Log(LOGERROR, "getDisplayConfigs failed!");
+      return false;
+  }
+  int32_t attr_values[2];
+  uint32_t attributes[] = { HWC_DISPLAY_WIDTH, HWC_DISPLAY_HEIGHT, HWC_DISPLAY_NO_ATTRIBUTE };
+
+  m_hwcDevicePtr->getDisplayAttributes(m_hwcDevicePtr, 0, configs[0], attributes, attr_values);
+
+  res->iWidth = attr_values[0];
+  res->iHeight = attr_values[1];
+
+  res->fRefreshRate  = 60;
+  res->dwFlags       = D3DPRESENTFLAG_PROGRESSIVE;
+  res->iScreen       = 0;
+  res->bFullScreen   = true;
+  res->iSubtitles    = (int)(0.965 * res->iHeight);
+  res->fPixelRatio   = 1.0f;
+  res->iScreenWidth  = res->iWidth;
+  res->iScreenHeight = res->iHeight;
+  res->strMode       = StringUtils::Format("%dx%d @ %.2f%s - Full Screen", res->iScreenWidth, res->iScreenHeight, res->fRefreshRate,
+  res->dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+  CLog::Log(LOGNOTICE,"Current resolution: %s\n",res->strMode.c_str());
+  return true;
+#endif
+}
+
+bool CEGLNativeTypeHybris::SetNativeResolution(const RESOLUTION_INFO &res)
+{
+  return false;
+}
+
+bool CEGLNativeTypeHybris::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)
+{
+  RESOLUTION_INFO res;
+  bool ret = false;
+  ret = GetNativeResolution(&res);
+  if (ret && res.iWidth > 1 && res.iHeight > 1)
+  {
+    resolutions.push_back(res);
+    return true;
+  }
+  return false;
+}
+
+bool CEGLNativeTypeHybris::GetPreferredResolution(RESOLUTION_INFO *res) const
+{
+  return false;
+}
+
+bool CEGLNativeTypeHybris::ShowWindow(bool show)
+{
+  return true;
+} 
+
+void CEGLNativeTypeHybris::SwapSurface(EGLDisplay display, EGLSurface surface)
+{
+}
+
+void CEGLNativeTypeHybris::WaitForVsync()
+{
+}
diff -rupN xbmc-master/xbmc/windowing/egl/EGLNativeTypeHybris.h isengard/xbmc/windowing/egl/EGLNativeTypeHybris.h
--- xbmc-master/xbmc/windowing/egl/EGLNativeTypeHybris.h	1970-01-01 10:00:00.000000000 +1000
+++ isengard/xbmc/windowing/egl/EGLNativeTypeHybris.h	2015-06-30 15:49:00.413720991 +1000
@@ -0,0 +1,85 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#if defined(TARGET_HYBRIS)
+#include <hwcomposerwindow/hwcomposer_window.h>
+#include <hardware/hardware.h>
+#include <hardware/hwcomposer.h>
+#endif
+
+#include "EGLNativeType.h"
+#include "threads/Thread.h"
+
+class CEGLNativeTypeHybris;
+
+class CHybrisVideoRenderer : public CThread
+{
+public:
+  CHybrisVideoRenderer(hwc_display_contents_1_t **bufferList,
+    hwc_composer_device_1_t *hwcDevicePtr,
+    HWComposerNativeWindow *nativeWindow);
+  virtual ~CHybrisVideoRenderer();
+private:
+  hwc_display_contents_1_t   **m_bufferList;
+  hwc_composer_device_1_t    *m_hwcDevicePtr;
+  HWComposerNativeWindow     *m_hwNativeWindow;
+protected:
+  void Process();
+};
+
+class CEGLNativeTypeHybris : public CEGLNativeType
+{
+public:
+  CEGLNativeTypeHybris();
+  virtual ~CEGLNativeTypeHybris();
+  virtual std::string GetNativeName() const { return "hybris"; };
+  virtual bool  CheckCompatibility();
+  virtual void  Initialize();
+  virtual void  Destroy();
+  virtual int   GetQuirks() { return 0; };
+
+  virtual bool  CreateNativeDisplay();
+  virtual bool  CreateNativeWindow();
+  virtual bool  GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const;
+  virtual bool  GetNativeWindow(XBNativeWindowType **nativeWindow) const;
+
+  virtual bool  DestroyNativeWindow();
+  virtual bool  DestroyNativeDisplay();
+
+  virtual bool  GetNativeResolution(RESOLUTION_INFO *res) const;
+  virtual bool  SetNativeResolution(const RESOLUTION_INFO &res);
+  virtual bool  ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions);
+  virtual bool  GetPreferredResolution(RESOLUTION_INFO *res) const;
+
+  virtual bool  ShowWindow(bool show);
+  virtual void  WaitForVsync();
+  void SwapSurface(EGLDisplay display, EGLSurface surface);
+#if defined(TARGET_HYBRIS)
+private:
+  hw_module_t                *m_hwcModule;
+  hwc_display_contents_1_t   **m_bufferList;
+  hwc_composer_device_1_t    *m_hwcDevicePtr;
+  HWComposerNativeWindow     *m_hwNativeWindow;
+  ANativeWindow              *m_swNativeWindow;
+#endif
+  CHybrisVideoRenderer       *m_videoRenderThread;
+};
diff -rupN xbmc-master/xbmc/windowing/egl/EGLWrapper.cpp isengard/xbmc/windowing/egl/EGLWrapper.cpp
--- xbmc-master/xbmc/windowing/egl/EGLWrapper.cpp	2015-06-30 04:17:51.000000000 +1000
+++ isengard/xbmc/windowing/egl/EGLWrapper.cpp	2015-06-30 15:49:00.413720991 +1000
@@ -33,6 +33,9 @@
 #if defined(TARGET_RASPBERRY_PI)
   #include "EGLNativeTypeRaspberryPI.h"
 #endif
+#ifdef HAS_HYBRIS
+#include "EGLNativeTypeHybris.h"
+#endif 
 #if defined(HAS_IMXVPU)
   #include "EGLNativeTypeIMX.h"
 #endif
@@ -102,6 +105,9 @@ bool CEGLWrapper::Initialize(const std::
 #if defined(TARGET_RASPBERRY_PI)
       (nativeGuess = CreateEGLNativeType<CEGLNativeTypeRaspberryPI>(implementation)) ||
 #endif
+#ifdef HAS_HYBRIS
+      (nativeGuess = CreateEGLNativeType<CEGLNativeTypeHybris>(implementation)) ||
+#endif 
 #if defined(HAS_IMXVPU)
       (nativeGuess = CreateEGLNativeType<CEGLNativeTypeIMX>(implementation)) ||
 #endif
diff -rupN xbmc-master/xbmc/windowing/egl/Makefile.in isengard/xbmc/windowing/egl/Makefile.in
--- xbmc-master/xbmc/windowing/egl/Makefile.in	2015-06-30 04:17:51.000000000 +1000
+++ isengard/xbmc/windowing/egl/Makefile.in	2015-06-30 15:49:00.413720991 +1000
@@ -10,6 +10,9 @@ endif
 ifeq (@USE_MMAL@,1)
 SRCS+= EGLNativeTypeRaspberryPI.cpp
 endif
+ifeq (@USE_HYBRIS@,1)
+SRCS+= EGLNativeTypeHybris.cpp
+endif 
 ifeq (@USE_IMXVPU@,1)
 SRCS+= EGLNativeTypeIMX.cpp
 endif
